<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>OptiML's Euro/NeurIPS VRP challenge presentation</title>
    <link rel="shortcut icon" href="./../favicon.ico" />
    <link rel="stylesheet" href="./../dist/reveal.css" />
    <link rel="stylesheet" href="./../dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="./../css/highlight/github.css" />


  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">

# Solving a static and dynamic VRP with time windows

<br />

**OptiML**

Jasper van Doorn, Leon Lan, Luuk Pentinga, Niels Wouda

7 December 2022
</script></section><section ><section data-markdown><script type="text/template">
# Static solver

High-level overview:

- Simplify given baseline
- Tweak local search
- (and more that we do not have time for)

<aside class="notes"><p>The first two are what I want to explain in more detail today.
Since we do not have a lot of time, I will not go into what we did for diversity management, or how we tuned the many parameters of our static solver.
That is also very interesting (and turned out to be really important, too!), so if you want to know more, we refer to both the codebase and the four-page summary paper on our methods.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Simplify baseline

- First, we refactored the entire codebase, and added Python bindings.
- Then, we removed:
  - constructive heuristics
  - circle sectors
  - giant tour representation and split algorithm
  - dynamic growth of granular neighbourhoods and minimum population size

> Our ``Config`` object has 26 fields, compared to the baseline's 42.

<aside class="notes"><p>Constructive heuristics could be removed because we wanted to get into the main genetic search loop as quickly as possible.
Our initial population is randomly generated.
We removed the circle sectors because we do intensification somewhat differently (more on that in the next slide).
The giant tour representation and the linear split algorithm were only needed for the ordered exchange crossover.
We remove that crossover, which meant we no longer needed to store the giant tour.
The dynamic growth parameters did not seem to help much because the sizes they control are already &#39;large enough&#39;. </p>
<p>Removing all this did not seem to hurt performance at all.
So we more or less made everything much simpler at zero cost to performance.</p>
<p>Having many fewer parameters was a big boon when it came to tuning.</p>
</aside></script></section><section data-markdown><script type="text/template">
## Tweak local search

<div style="display: flex;">

<div style="max-width: 50%; flex: 1;">

Baseline:

- Always at least two iterations. Later iterations tests against empty routes.
- Probabilistically apply intensification with RELOCATE* and SWAP*.
- Uses circle sector restriction for intensification.
- Hard-coded operators.

</div>

<div style="max-width: 50%; flex: 1;">

Ours:

- One iteration if no improvement. Empty routes very rarely result in improvement.
- Apply intensification only for new best individuals. 
- Since new best individuals are fairly rare, no circle sector restriction is needed.
- Modular operator set.
- Templated $(N, M)$ exchange with many small performance tweaks.
</div>

</div>

<aside class="notes"><p>Our operators are stored as lists of function pointers.
We run through these and apply the operators.
So not running an operator is as easy as not providing it to the local search in the first place.</p>
<p>$(N, M)$ exchange covers six out of eight node-based operators.
So having one bit of code for all that means we can very effectively improve a lot of operators at the same time.</p>
</aside></script></section></section><section ><section data-markdown><script type="text/template">
# Dynamic solver

Idea:
> Simulate ahead to determine which requests to postpone

<aside class="notes"><p>This is easiest to explain via an example, which we will go through in the next few slides.</p>
</aside></script></section><section data-markdown><script type="text/template">
<img width="80%" src="images/epoch_instance_2.svg" />

<aside class="notes"><p>This slide shows the epoch instance, that is, all requests available at the
start of an epoch. The requests are color-coded: red for must-dispatch requests
and yellow for optional requests. The depot a big blue star.</p>
</aside></script></section><section data-markdown><script type="text/template">
<img width="80%" src="images/simulation_instance_2_0_0.svg" />

<aside class="notes"><p>This slide shows the simulation instance. The simulation instance is the epoch
instance, together with a set of sampled future requests. The sampled future
requests have smaller node sizes and grey color, to distinguish from the
epoch requests.</p>
</aside></script></section><section data-markdown><script type="text/template">
<img width="80%" src="images/simulation_instance_with_solution_2_0_0.svg" />

<aside class="notes"><p>This slide shows the simulation solution, i.e., the solution that is obtained
by solving the simulation instance. Each route starts and ends at the depot.
Routes that do not contain any must-dispatch requests are colored green/grey.
Routes that do contain must-dispatch requests are colored red.</p>
<p>It is important to highlight in this slide that we are solving a VRPTW with
release dates. So if an optional request is on a &quot;green/grey&quot; route, then it
is in fact postponed.</p>
<p>It should also be mentioned that these instances are solved very fast, with
less than 0.5 seconds time limits.</p>
</aside></script></section><section data-markdown><script type="text/template">
<svg width="80%" height="100%" viewBox="0 0 720 540" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <image width="100%" height="100%" xlink:href="images/cycle0/simulation_instance_with_solution_2_0_4.jpg">
    <animate attributeName="xlink:href" 
      values="images/cycle0/simulation_instance_with_solution_2_0_4.svg;images/cycle0/simulation_instance_with_solution_2_0_6.svg;images/cycle0/simulation_instance_with_solution_2_0_7.svg;images/cycle0/simulation_instance_with_solution_2_0_9.svg;images/cycle0/simulation_instance_with_solution_2_0_11.svg;images/cycle0/simulation_instance_with_solution_2_0_12.svg;" 
      begin="0s" repeatCount="indefinite" dur="6s"/>
  </image>
</svg>

<aside class="notes"><p>This slide shows a gif, each frame showing a new simulation instance and
its corresponding solution.</p>
<p>We should mention here that we run about 40-50 simulations.</p>
</aside></script></section><section data-markdown><script type="text/template">
<img width="80%" src="images/epoch_instance_with_labels_2_0.svg" />

<aside class="notes"><p>This slide shows the epoch instance, with labels for each optional request
indicating its postponement frequency.</p>
</aside></script></section><section data-markdown><script type="text/template">
<img width="80%" src="images/epoch_instance_with_labels_and_colors_2_0.svg" />

<aside class="notes"><p>This slide is the same as the previous one, but now the optional requests
with high postponement frequency are colored green to indicate postponement.</p>
</aside></script></section><section data-markdown><script type="text/template">
<svg width="80%" height="100%" viewBox="0 0 720 540" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <image width="100%" height="100%" xlink:href="images/cycle1/simulation_instance_with_solution_2_1_1.jpg">
    <animate attributeName="xlink:href" 
      values="images/cycle1/simulation_instance_with_solution_2_1_1.svg;images/cycle1/simulation_instance_with_solution_2_1_2.svg;images/cycle1/simulation_instance_with_solution_2_1_4.svg;images/cycle1/simulation_instance_with_solution_2_1_6.svg;images/cycle1/simulation_instance_with_solution_2_1_7.svg;images/cycle1/simulation_instance_with_solution_2_1_8.svg;" 
      begin="0s" repeatCount="indefinite" dur="6s"/>
  </image>
</svg>

<aside class="notes"><p>This slide shows the next simulation cycle, where the previously postponed
requests are colored green. Each frame shows another solved simulation instance.</p>
</aside></script></section><section data-markdown><script type="text/template">
<img width="80%" src="images/epoch_instance_with_labels_and_colors_2_1.svg" />
</script></section><section data-markdown><script type="text/template">
<img width="80%" src="images/dispatch_instance_2.svg" />

<aside class="notes"><p>This slide shows the final dispatch instance, which is obtained after the last
simulation cycle.</p>
</aside></script></section><section data-markdown><script type="text/template">
<img width="80%" src="images/dispatch_instance_with_solution_2.svg" />

<aside class="notes"><p>This slide shows the dispatch solution. We highlight the routes that do not
contain any must dispatch routes green.</p>
</aside></script></section><section data-markdown><script type="text/template">
<img width="80%" src="images/dispatch_instance_with_solution_plus_2.svg" />

<aside class="notes"><p>This slide shows the final dispatch solution and the final dispatch instance,
where we removed all postpone-able routes from the dispatch solution.</p>
</aside></script></section></section><section  data-markdown><script type="text/template">
# Questions?

n.a.wouda@rug.nl
</script></section></div>
    </div>

    <script src="./../dist/reveal.js"></script>

    <script src="./../plugin/markdown/markdown.js"></script>
    <script src="./../plugin/highlight/highlight.js"></script>
    <script src="./../plugin/zoom/zoom.js"></script>
    <script src="./../plugin/notes/notes.js"></script>
    <script src="./../plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"width":1600,"height":1050,"transition":"slide","slideNumber":"c","chalkboard":{"grid":false,"theme":"whiteboard","toggleChalkboardButton":false,"toggleNotesButton":false},"menu":{"numbers":"c","markers":false,"hideMissingTitles":true},"math":{"TeX":{"jax":["input/TeX","output/SVG"]}}}, queryOptions);
    </script>

    <script src="./../_assets/plugin/chalkboard/plugin.js"></script>
    <script src="./../_assets/plugin/menu/menu.js"></script>
    <script src="./../_assets/plugin/plugin.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
